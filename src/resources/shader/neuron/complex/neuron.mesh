#version 460
#extension GL_EXT_mesh_shader: enable

const float M_PI = 3.1415926535897932384626433832795f;

const int MAX_POINTS_PER_CIRCLE = 16;
const int GROUPS_SIZE = MAX_POINTS_PER_CIRCLE * 2;

layout (local_size_x = GROUPS_SIZE, local_size_y = 1, local_size_z = 1) in;
layout (triangles) out;
layout (max_vertices = GROUPS_SIZE, max_primitives = GROUPS_SIZE) out;

layout (set = 0, binding = 0) uniform Matrices {
    mat4 view;
    mat4 viewProjection;
    mat4 inverseProjection;
    float near;
    float far;
};

layout (set = 0, binding = 1) uniform GlobalData {
    float currentTime;
    float radiusStrength;
    float startClip;
    float endClip;
    float splitHeight;
    float splitArcStrength;
    uint rotationIndexOffset;
    uint childrenRotationIndexOffset;
    uint minChildrenForJoint;
    uint verticesPerCircle;
    uint somaLatitudes;
    uint somaLongitudes;
    float somaConnectionPushFactor;
    float somaWeightPower;
    float somaSphereWeight;
    float somaConnectionMaxWeight;
    vec4 defaultColor;
    vec4 selectedColor;
    uint lod;
};

struct Neuron {
    uint neuronId;
    mat4 model;
    mat4 normal;
};

struct Section {
    uint neuronIndex;
    uint sectionId;
    uint metadata;
    uint parent;// This is the index inside the sections array! It is not the id of the section.
    vec4 endAndRadius;
};

layout(std430, set = 2, binding = 0) buffer Neurons {
    Neuron neurons[];
};

layout(std430, set = 2, binding = 1) buffer Data {
    Section sections[];
};

layout(std430, set = 2, binding = 4) buffer Selection {
    bool selected[];
};

struct TaskData {
    uint section[32];
    uint lodNextToParent[32];
    uint children[32];
    uint amount;
    uint childrenAmount;
};

taskPayloadSharedEXT TaskData td;

layout(location = 0) out vec3 fragNormal[];
layout(location = 1) flat out float fragType[];
layout(location = 2) flat out float fragNeuronId[];
layout(location = 3) flat out float fragSectionId[];
layout(location = 4) flat out float fragSelected[];

void pushVertex(uint i, vec4 position, vec3 normal, uint type, Neuron neuron, uint sectionId, bool sel) {
    gl_MeshVerticesEXT[i].gl_Position = viewProjection * neuron.model * position;
    fragNormal[i] = mat3(neuron.normal) * normal;
    fragType[i] = uintBitsToFloat(type);
    fragNeuronId[i] = uintBitsToFloat(neuron.neuronId);
    fragSectionId[i] = uintBitsToFloat(sectionId);
    fragSelected[i] = sel ? 1.0f : 0.0f;
}

vec3 rotate (vec3 v, vec3 n, float a) {
    return v * cos(a) + cross(n, v) * sin(a) + n * dot(n, v) * (1. - cos(a));
}

void generateSection(uint sectionIndex, uint nextToParentIndex) {
    if (gl_LocalInvocationID.x >= verticesPerCircle * 2) return;

    Section section = sections[sectionIndex];
    Section directParent = sections[section.parent];
    Section directGrandparent = sections[directParent.parent];

    Section nextToParent = sections[nextToParentIndex];
    Section parent = sections[nextToParent.parent];
    Section grandParent = sections[parent.parent];
    Neuron neuron = neurons[section.neuronIndex];

    uint parentType = parent.metadata & 255u;
    uint sectionType = section.metadata & 255u;
    bool parentSoma = parentType == 1;

    // If is soma or has no children...
    if (sectionType == 1 || parentSoma || section.sectionId == parent.sectionId) {
        SetMeshOutputsEXT(0, 0);
        return;
    }

    // Fetch initial data.
    bool first = gl_LocalInvocationID.x < verticesPerCircle;
    bool isSelected = selected[sectionIndex];
    uint parentChildren = (parent.metadata >> 8u) & 7u;
    uint sectionChildren = (section.metadata >> 8u) & 7u;
    bool hasStartJoint = parentChildren >= minChildrenForJoint;
    bool hasEndJoint = sectionChildren >= minChildrenForJoint;

    float sClip = hasStartJoint ? startClip : 0.0f;
    float eClip = hasEndJoint ? endClip : 0.0f;

    vec3 end = section.endAndRadius.xyz;
    vec3 directStart = directParent.endAndRadius.xyz;
    vec3 start = parent.endAndRadius.xyz;
    vec3 parentStart = grandParent.endAndRadius.xyz;

    float startRadius = mix(parent.endAndRadius.w, nextToParent.endAndRadius.w, parentSoma ? 1.0f : sClip);
    float endRadius = mix(directParent.endAndRadius.w, section.endAndRadius.w, 1.0f - eClip);
    float radius = (first ? startRadius : endRadius) * radiusStrength;

    float angle = float(gl_LocalInvocationID.x) / float(verticesPerCircle) * 2.0f * M_PI;

    vec3 unormDirection = end - directStart;
    vec3 parentUnormDirection = nextToParent.endAndRadius.xyz - start;

    vec3 direction = normalize(unormDirection);
    vec3 parentDirection = (parent.sectionId == grandParent.sectionId || parentSoma)
    ? direction
    : normalize(start - parentStart);

    // Correctly align the initial basis for the start circle
    vec3 tangent = (first && !hasStartJoint) ? parentDirection : direction;

    // Handle edge cases where the tangent might align with the default normal
    vec3 initialNormal = vec3(0, 0, -1);
    if (abs(dot(tangent, initialNormal)) > 0.99) {
        initialNormal = vec3(0, 1, 0);// Use a different axis to avoid parallel vectors
    }

    vec3 normal = normalize(cross(tangent, initialNormal));
    vec3 binormal = cross(tangent, normal);

    // Smoothly transition basis along the tube.
    // Here we want to generate the tube using the parent direction,
    // but avoiding the candy-wrap effect.
    if (!first && !hasStartJoint) {
        vec3 projectedNormal = normal - dot(normal, tangent) * tangent;// Project onto the tangent plane
        normal = normalize(projectedNormal);
        binormal = cross(tangent, normal);
    }

    // Compute the rotated position for each vertex
    vec3 rotated = cos(angle) * normal + sin(angle) * binormal;

    vec3 center = first ? (start + unormDirection * sClip) : end - unormDirection * eClip;

    vec3 point = center + rotated * radius;
    SetMeshOutputsEXT(verticesPerCircle * 2, verticesPerCircle * 2);
    pushVertex(gl_LocalInvocationID.x, vec4(point, 1), rotated, 0, neuron, section.sectionId, isSelected);

    uint a = gl_LocalInvocationID.x;
    uint b = (gl_LocalInvocationID.x + 1) % verticesPerCircle;
    uint c = (gl_LocalInvocationID.x + (first ? 0 : 1)) % verticesPerCircle + verticesPerCircle;
    gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationID.x] = uvec3(a, b, c);
}

void generateEnd (uint sectionIndex) {
    if (gl_LocalInvocationID.x >= verticesPerCircle) return;

    Section section = sections[sectionIndex];
    Section parent = sections[section.parent];
    Neuron neuron = neurons[section.neuronIndex];

    uint parentType = parent.metadata & 255u;
    uint sectionType = section.metadata & 255u;
    // If is soma or has no children...
    if (sectionType == 1 || section.sectionId == parent.sectionId) {
        SetMeshOutputsEXT(0, 0);
        return;
    }

    // Fetch initial data.
    bool first = gl_LocalInvocationID.x < verticesPerCircle;
    bool isSelected = selected[sectionIndex];
    uint parentChildren = (parent.metadata >> 8u) & 7u;
    uint sectionChildren = (section.metadata >> 8u) & 7u;
    bool hasStartJoint = parentChildren >= minChildrenForJoint;
    bool hasEndJoint = sectionChildren >= minChildrenForJoint;

    float eClip = hasEndJoint ? endClip : 0.0f;

    vec3 end = section.endAndRadius.xyz;
    vec3 start = parent.endAndRadius.xyz;

    float radius = section.endAndRadius.w * radiusStrength;

    float angle = float(gl_LocalInvocationID.x) / float(verticesPerCircle) * 2.0f * M_PI;

    vec3 tangent = normalize(end - start);

    // Handle edge cases where the tangent might align with the default normal
    vec3 initialNormal = vec3(0, 0, -1);
    if (abs(dot(tangent, initialNormal)) > 0.99) {
        initialNormal = vec3(0, 1, 0);// Use a different axis to avoid parallel vectors
    }

    vec3 normal = normalize(cross(tangent, initialNormal));
    vec3 binormal = cross(tangent, normal);

    // Compute the rotated position for each vertex
    vec3 rotated = cos(angle) * normal + sin(angle) * binormal;
    vec3 point = end + rotated * radius;


    vec3 edge = end + tangent * radius;

    SetMeshOutputsEXT(verticesPerCircle + 1, verticesPerCircle);
    pushVertex(gl_LocalInvocationID.x, vec4(point, 1), rotated, 0, neuron, section.sectionId, isSelected);
    pushVertex(verticesPerCircle, vec4(edge, 1), tangent, 0, neuron, section.sectionId, isSelected);

    uint a = gl_LocalInvocationID.x;
    uint b = (gl_LocalInvocationID.x + 1) % verticesPerCircle;
    gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationID.x] = uvec3(a, b, verticesPerCircle);
}

void main() {
    if (gl_WorkGroupID.x >= td.amount) {
        uint section = td.children[gl_WorkGroupID.x - td.amount];
        generateEnd(section);
    } else {
        uint section = td.section[gl_WorkGroupID.x];
        uint nextToParent = td.lodNextToParent[gl_WorkGroupID.x];
        generateSection(section, nextToParent);
    }
}