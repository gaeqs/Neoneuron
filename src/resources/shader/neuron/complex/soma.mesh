#version 460
#extension GL_EXT_mesh_shader: enable
#extension GL_KHR_shader_subgroup_ballot: enable

const float M_PI = 3.1415926535897932384626433832795f;

const uint MAX_SOMA_CONNECTIONS = 8;
const uint MAX_CONNECTION_VERTICES = 32;

const uint MAX_LAT_VERTICES = 32;
const uint MAX_LONG_VERTICES = 32;
const uint MAX_VERTICES = MAX_LAT_VERTICES * MAX_LONG_VERTICES;
const uint STORAGE_PER_SOMA = MAX_VERTICES;

const uint LAT_VERTICES = 16;
const uint LONG_VERTICES = 32;
const uint VERTICES = LAT_VERTICES * LONG_VERTICES;

// Define the maximum vertices and primitives for the mesh shader
const uint GROUP_VERTICES = LONG_VERTICES * 2;
const uint GROUP_PRIMITIVES = LONG_VERTICES * 2;

layout (local_size_x = LONG_VERTICES, local_size_y = 1, local_size_z = 1) in;
layout (triangles) out;
layout(max_vertices = GROUP_VERTICES, max_primitives = GROUP_PRIMITIVES) out;

layout (set = 0, binding = 0) uniform Matrices {
    mat4 view;
    mat4 viewProjection;
    mat4 inverseProjection;
    float near;
    float far;
};

layout (set = 0, binding = 1) uniform GlobalData {
    float currentTime;
    float radiusStrength;
    float startClip;
    float endClip;
    float splitHeight;
    float splitArcStrength;
    uint rotationIndexOffset;
    uint childrenRotationIndexOffset;
    uint minChildrenForJoint;
    uint verticesPerCircle;
    vec4 defaultColor;
    vec4 selectedColor;
};

struct Section {
    uint neuronId;
    uint sectionId;
    uint metadata;
    uint parent;// This is the index inside the sections array! It is not the id of the section.
    vec4 endAndRadius;
};

struct Soma {
    uint sectionIndex;
    uint amount;
    uint connection[MAX_SOMA_CONNECTIONS];
};

layout(std430, set = 2, binding = 0) buffer Data {
    Section sections[];
};

layout(std430, set = 2, binding = 2) buffer Somas {
    Soma somas[];
};

layout(std430, set = 2, binding = 3) buffer Selection {
    bool selected[];
};

layout(std430, set = 2, binding = 4) buffer SomaGPUData {
    uint packedConnection[];
};

struct TaskData {
    uint somaIndex;
};

taskPayloadSharedEXT TaskData td;

layout(location = 0) out vec3 fragNormal[];
layout(location = 1) out vec3 fragColor[];
layout(location = 2) flat out float fragNeuronId[];
layout(location = 3) flat out float fragSectionId[];
layout(location = 4) flat out float fragSelected[];


shared uint connectionVerticesIndices[MAX_CONNECTION_VERTICES];
shared vec3 connectionVertices[MAX_CONNECTION_VERTICES];
shared float connectionVerticesAngles[MAX_CONNECTION_VERTICES];

vec3 closestPointInSegment(vec3 from, vec3 to, vec3 point) {
    vec3 v = point - from;
    vec3 dir = to - from;
    float l2 = dot(dir, dir);
    float d = clamp(dot(v, dir) / l2, 0.0f, 1.0f);
    return from + d * dir;
}

bool isInsideSphere(vec3 center, float radius, vec3 point) {
    vec3 l = point - center;
    return dot(l, l) <= radius * radius;
}

vec3 projectToSphere(vec3 center, float radius, vec3 point) {
    return center + normalize(point - center) * radius;
}

vec3 projectToCapsule(vec3 from, vec3 to, float radius, vec3 point) {
    vec3 center = closestPointInSegment(from, to, point);
    return projectToSphere(center, radius, point);
}

uint fetchConnection(uint vertex) {
    uint index = td.somaIndex * STORAGE_PER_SOMA + vertex / 4;
    uint subindex = vertex % 4;
    uint packed = packedConnection[index];
    return (packed >> (subindex * 8u)) & 255u;
}

void swapVertices(uint i, uint j) {
    float tempAngle = connectionVerticesAngles[i];
    uint tempIndex = connectionVerticesIndices[i];
    vec3 tempVertex = connectionVertices[i];

    connectionVerticesAngles[i] = connectionVerticesAngles[j];
    connectionVerticesIndices[i] = connectionVerticesIndices[j];
    connectionVertices[i] = connectionVertices[j];


    connectionVerticesAngles[j] = tempAngle;
    connectionVerticesIndices[j] = tempIndex;
    connectionVertices[j] = tempVertex;
}

void verticesBitonicSort(uint verticesAmount) {
    for (uint k = 2; k <= LONG_VERTICES; k *= 2) {
        for (uint j = k / 2; j > 0; j /= 2) {
            uint idx = gl_LocalInvocationID.x;

            uint i = idx ^ j;
            if (i > idx) {
                if ((idx & k) == 0) {
                    if (connectionVerticesAngles[idx] > connectionVerticesAngles[i]) {
                        swapVertices(idx, i);
                    }
                } else {
                    if (connectionVerticesAngles[idx] < connectionVerticesAngles[i]) {
                        swapVertices(idx, i);
                    }
                }
            }
            barrier();
        }
    }
}

void pushVertex(uint i, vec3 position, vec3 normal, uint type, uint neuronId, uint sectionId, bool sel) {
    gl_MeshVerticesEXT[i].gl_Position = viewProjection * vec4(position, 1.0f);
    fragNormal[i] = normal;
    fragNeuronId[i] = uintBitsToFloat(neuronId);
    fragSectionId[i] = uintBitsToFloat(sectionId);
    fragSelected[i] = sel ? 1.0f : 0.0f;

    if (type == 0) {
        fragColor[i] = vec3(0, 1, 0);
    } else if (type == 1) {
        fragColor[i] = vec3(0, 0, 1);
    } else if (type == 2) {
        fragColor[i] = vec3(1, 1, 0);
    } else if (type == 3) {
        fragColor[i] = vec3(1, 1, 1);
    } else if (type == 4) {
        fragColor[i] = vec3(0.5f, 0.5f, 0.5f);
    } else if (type == 5) {
        fragColor[i] = vec3(1, 0.5f, 0.5f);
    } else if (type == 6) {
        fragColor[i] = vec3(0.5f, 1, 0.5f);
    } else if (type == 7) {
        fragColor[i] = vec3(0.5f, 0.5f, 1);
    } else {
        fragColor[i] = defaultColor.xyz;
    }
}

void generateSomaPart () {
    Soma soma = somas[td.somaIndex];
    Section section = sections[soma.sectionIndex];
    bool isSelected = selected[soma.sectionIndex];

    SetMeshOutputsEXT(GROUP_VERTICES, GROUP_PRIMITIVES);

    float radius = section.endAndRadius.w;
    vec3 center = section.endAndRadius.xyz;

    // Workgroup ID and total number of threads
    uint latitude = gl_WorkGroupID.x;
    uint longitude = gl_LocalInvocationID.x;

    float phi = float(longitude) / float(LONG_VERTICES) * 2.0 * M_PI;// Longitude angle (0 to 2π)
    float thetaTop = float(latitude) / float(LAT_VERTICES - 1) * M_PI;// Latitude angle (0 to π)
    float thetaBot = float(latitude + 1) / float(LAT_VERTICES - 1) * M_PI;// Latitude angle (0 to π)

    float cosPhi = cos(phi);
    float sinPhi = sin(phi);
    float cosThetaBot = cos(thetaBot);
    float sinThetaBot = sin(thetaBot);
    float cosThetaTop = cos(thetaTop);
    float sinThetaTop = sin(thetaTop);

    vec3 top = vec3(sinThetaTop * cosPhi, cosThetaTop, sinThetaTop * sinPhi) * radius + center;
    vec3 bot = vec3(sinThetaBot * cosPhi, cosThetaBot, sinThetaBot * sinPhi) * radius + center;

    uint topIndex = latitude * LONG_VERTICES + longitude;
    uint botIndex = (latitude + 1) * LONG_VERTICES + longitude;
    uint topConnection = fetchConnection(topIndex);
    uint botConnection = fetchConnection(botIndex);

    if (topConnection < MAX_SOMA_CONNECTIONS) {
        Section segment = sections[soma.connection[topConnection]];
        top = projectToCapsule(center, segment.endAndRadius.xyz, segment.endAndRadius.w, top);
    }

    if (botConnection < MAX_SOMA_CONNECTIONS) {
        Section segment = sections[soma.connection[botConnection]];
        bot = projectToCapsule(center, segment.endAndRadius.xyz, segment.endAndRadius.w, bot);
    }

    vec3 normalTop = normalize(top - center);
    vec3 normalBot = normalize(bot - center);

    pushVertex(longitude, top, normalTop, topConnection, section.neuronId, section.sectionId, false);
    pushVertex(longitude + LONG_VERTICES, bot, normalBot, botConnection, section.neuronId, section.sectionId, false);

    uint a = longitude;
    uint b = (a + 1) % LONG_VERTICES;
    uint c = a + LONG_VERTICES;
    uint d = b + LONG_VERTICES;

    uint ia = fetchConnection(latitude * LONG_VERTICES + a);
    uint ib = fetchConnection(latitude * LONG_VERTICES + b);
    uint ic = fetchConnection(latitude * LONG_VERTICES + c);
    uint id = fetchConnection(latitude * LONG_VERTICES + d);

    if (ia != ib || ia != ic || ia == MAX_SOMA_CONNECTIONS) {
        gl_PrimitiveTriangleIndicesEXT[longitude * 2 + 0] = uvec3(a, b, c);
    } else {
        gl_PrimitiveTriangleIndicesEXT[longitude * 2 + 0] = uvec3(a, a, a);
    }
    if (id != ib || id != ic || id == MAX_SOMA_CONNECTIONS) {
        gl_PrimitiveTriangleIndicesEXT[longitude * 2 + 1] = uvec3(c, b, d);
    } else {
        gl_PrimitiveTriangleIndicesEXT[longitude * 2 + 1] = uvec3(d, d, d);
    }
}

void generateConnection () {
    uint currentConnection = gl_WorkGroupID.x - LAT_VERTICES;

    Soma soma = somas[td.somaIndex];
    Section somaSection = sections[soma.sectionIndex];
    Section connectionSection = sections[soma.connection[currentConnection]];

    // Find the indices of all vertices that have been selected by this connection.

    uint verticesAmount = 0;
    for (uint vertexIndex = gl_LocalInvocationID.x; vertexIndex < VERTICES; vertexIndex += gl_WorkGroupSize.x) {
        uint connection = fetchConnection(vertexIndex);
        bool connected = connection == currentConnection;
        uvec4 vote = subgroupBallot(connected);
        uint arrayId = verticesAmount + subgroupBallotExclusiveBitCount(vote);
        if (connected) {
            connectionVerticesIndices[arrayId] = vertexIndex;
        }

        verticesAmount += subgroupBallotBitCount(vote);
    }

    barrier();

    float radius = somaSection.endAndRadius.w;
    vec3 somaCenter = somaSection.endAndRadius.xyz;
    vec3 direction = normalize(connectionSection.endAndRadius.xyz - somaCenter);
    vec3 center = somaCenter + direction * radius;

    vec3 initialNormal = vec3(0, 0, -1);
    if (abs(dot(direction, initialNormal)) > 0.99) {
        initialNormal = vec3(0, 1, 0);// Use a different axis to avoid parallel vectors
    }

    vec3 tangent = cross(direction, initialNormal);
    vec3 bitangent = cross(direction, tangent);

    // Generate the vertices.
    for (uint i = gl_LocalInvocationID.x; i < verticesAmount; i += gl_WorkGroupSize.x) {
        uint vertexIndex = connectionVerticesIndices[i];
        uint latitude = vertexIndex / LONG_VERTICES;
        uint longitude = vertexIndex % LONG_VERTICES;

        float phi = float(longitude) / float(LONG_VERTICES) * 2.0 * M_PI;// Longitude angle (0 to 2π)
        float theta = float(latitude) / float(LAT_VERTICES - 1) * M_PI;// Latitude angle (0 to π)

        float cosPhi = cos(phi);
        float sinPhi = sin(phi);
        float cosTheta = cos(theta);
        float sinTheta = sin(theta);

        vec3 vertex = vec3(sinTheta * cosPhi, cosTheta, sinTheta * sinPhi) * radius + center;
        connectionVertices[i] = vertex;

        vec3 localVertex = vertex - center;
        float angle = atan(dot(localVertex, bitangent), dot(localVertex, tangent));
        if (angle < 0.0f) angle += 2.0f * M_PI;
        connectionVerticesAngles[i] = angle;
    }

    barrier();
    verticesBitonicSort(); // Sort already does a barrier.

    packedConnection[150 + currentConnection] = verticesAmount;

    for (uint i = gl_LocalInvocationID.x; i < verticesAmount; i += gl_WorkGroupSize.x) {
        packedConnection[200 + 100 * currentConnection + i] = uint(connectionVerticesAngles[i] * 180.f / M_PI);
    }
}

void main() {
    if (gl_WorkGroupID.x < LAT_VERTICES) {
        generateSomaPart();
    } else {
        generateConnection();
    }
}