#version 460
#extension GL_EXT_mesh_shader: enable

const float M_PI = 3.1415926535897932384626433832795f;

const uint MAX_POINTS_PER_CIRCLE = 16;
const uint MAX_HALF_CIRCLE = MAX_POINTS_PER_CIRCLE / 2;
const uint GROUPS_SIZE = MAX_POINTS_PER_CIRCLE * 2;

layout (local_size_x = GROUPS_SIZE, local_size_y = 1, local_size_z = 1) in;
layout (triangles) out;
layout (max_vertices = MAX_POINTS_PER_CIRCLE * 3 + MAX_HALF_CIRCLE, max_primitives = MAX_POINTS_PER_CIRCLE * 4 + 4) out;

layout (set = 0, binding = 0) uniform Matrices {
    mat4 view;
    mat4 viewProjection;
    mat4 inverseProjection;
    float near;
    float far;
};

layout (set = 0, binding = 1) uniform GlobalData {
    float currentTime;
    float radiusStrength;
    float startClip;
    float endClip;
    float splitHeight;
    float splitArcStrength;
    uint rotationIndexOffset;
    uint childrenRotationIndexOffset;
    uint minChildrenForJoint;
    uint verticesPerCircle;
    vec4 defaultColor;
    vec4 selectedColor;
};

struct Section {
    uint neuronId;
    uint sectionId;
    uint metadata;
    uint parent;// This is the index inside the sections array! It is not the id of the section.
    vec4 endAndRadius;
};

struct Joint {
    uint parent;
    uint amount;
    uint rotationIndex;// Rotation index data will always be 0-15!
    uint connection[7];
};

layout(std430, set = 2, binding = 0) buffer Data {
    Section sections[];
};

layout(std430, set = 2, binding = 1) buffer Joints {
    Joint joints[];
};

layout(std430, set = 2, binding = 2) buffer Selection {
    bool selected[];
};

struct TaskData {
    uint joint;
};

taskPayloadSharedEXT TaskData td;

shared vec3 parentCircle[MAX_POINTS_PER_CIRCLE];

layout(location = 0) out vec3 fragNormal[];
layout(location = 1) flat out float fragType[];
layout(location = 2) flat out float fragNeuronId[];
layout(location = 3) flat out float fragSectionId[];
layout(location = 4) flat out float fragSelected[];


void pushVertex(uint i, vec4 position, vec3 normal, uint type, uint neuronId, uint sectionId, bool sel) {
    gl_MeshVerticesEXT[i].gl_Position = viewProjection * (position);
    fragNormal[i] = normal;
    fragType[i] = uintBitsToFloat(type);
    fragNeuronId[i] = uintBitsToFloat(neuronId);
    fragSectionId[i] = uintBitsToFloat(sectionId);
    fragSelected[i] = sel ? 1.0f : 0.0f;
}

vec3 rotate (vec3 v, vec3 n, float a) {
    return v * cos(a) + cross(n, v) * sin(a) + n * dot(n, v) * (1. - cos(a));
}

void generateTube (vec3 startCenter, vec3 endCenter, vec3 startDirection, vec3 endDirection,
float startRadius, float endRadius,
uint rotationIndex, uint childrenRotationIndex,
uint neuronId,
uint startSectionId, uint endSectionId) {
    bool first = gl_LocalInvocationID.x < verticesPerCircle;
    uint finalRotationIndex = first ? rotationIndex : childrenRotationIndex;
    float angle = float(gl_LocalInvocationID.x + finalRotationIndex) / float(verticesPerCircle) * 2.0f * M_PI;


    // Correctly align the initial basis for the start circle
    vec3 tangent = first ? startDirection : endDirection;

    // Handle edge cases where the tangent might align with the default normal
    vec3 initialNormal = vec3(0, 0, -1);
    if (abs(dot(tangent, initialNormal)) > 0.99) {
        initialNormal = vec3(0, 1, 0);// Use a different axis to avoid parallel vectors
    }

    vec3 normal = normalize(cross(tangent, initialNormal));
    vec3 binormal = cross(tangent, normal);

    // Smoothly transition basis along the tube.
    // Here we want to generate the tube using the parent direction,
    // but avoiding the candy-wrap effect.
    if (!first) {
        vec3 projectedNormal = normal - dot(normal, tangent) * tangent;// Project onto the tangent plane
        normal = normalize(projectedNormal);
        binormal = cross(tangent, normal);
    }

    // Compute the rotated position for each vertex
    vec3 rotated = cos(angle) * normal + sin(angle) * binormal;

    vec3 center = first ? startCenter : endCenter;
    float radius = (first ? startRadius : endRadius) * radiusStrength;
    vec3 point = center + rotated * radius;
    uint sectionId = first ? startSectionId : endSectionId;

    pushVertex(gl_LocalInvocationID.x, vec4(point, 1), rotated, 0, neuronId, sectionId, false);

    uint a = gl_LocalInvocationID.x;
    uint b = (gl_LocalInvocationID.x + 1) % verticesPerCircle;
    uint c = (gl_LocalInvocationID.x + (first ? 0 : 1)) % verticesPerCircle + verticesPerCircle;
    gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationID.x] = uvec3(a, b, c);
}


void joint1(Joint joint) {
    SetMeshOutputsEXT(GROUPS_SIZE, GROUPS_SIZE);

    // Just joint the sections
    Section parent = sections[joint.parent];
    Section section = sections[joint.connection[0]];
    Section grandParent = sections[parent.parent];

    uint rotationIndex = (joint.rotationIndex + rotationIndexOffset) * verticesPerCircle / 16;
    uint childrenRotationIndex = (joint.rotationIndex + rotationIndexOffset + childrenRotationIndexOffset) * verticesPerCircle / 16;

    vec3 startDirectionUnorm = parent.endAndRadius.xyz - grandParent.endAndRadius.xyz;
    vec3 startDirection = normalize(startDirectionUnorm);
    vec3 endDirectionUnorm = section.endAndRadius.xyz - parent.endAndRadius.xyz;
    vec3 endDirection = normalize(endDirectionUnorm);

    vec3 startCenter = parent.endAndRadius.xyz - startDirectionUnorm * endClip;
    vec3 endCenter = parent.endAndRadius.xyz + endDirectionUnorm * startClip;

    float startRadius = mix(grandParent.endAndRadius.w, parent.endAndRadius.w, 1.0f - endClip);
    float endRadius = mix(parent.endAndRadius.w, section.endAndRadius.w, startClip);

    vec3 parentStart = grandParent.endAndRadius.xyz;

    generateTube(startCenter, endCenter, startDirection, endDirection, startRadius, endRadius, rotationIndex, childrenRotationIndex, section.neuronId, parent.sectionId, section.sectionId);
}

vec3 generateCircle (uint start, uint rotationIndex, vec3 center, vec3 direction,
vec3 parentDirection, float radius, uint neuronId, uint sectionId) {
    float angle = float(gl_LocalInvocationID.x + rotationIndex) / float(verticesPerCircle) * 2.0f * M_PI;

    // Correctly align the initial basis for the start circle
    vec3 tangent = direction;

    // Handle edge cases where the tangent might align with the default normal
    vec3 initialNormal = vec3(0, 0, -1);
    if (abs(dot(tangent, initialNormal)) > 0.99) {
        initialNormal = vec3(0, 1, 0);// Use a different axis to avoid parallel vectors
    }

    vec3 normal = normalize(cross(tangent, initialNormal));
    vec3 binormal = cross(tangent, normal);

    // Smoothly transition basis along the tube.
    vec3 projectedNormal = normal - dot(normal, tangent) * tangent;// Project onto the tangent plane
    normal = normalize(projectedNormal);
    binormal = cross(tangent, normal);

    // Compute the rotated position for each vertex
    vec3 rotated = cos(angle) * normal + sin(angle) * binormal;
    vec3 point = center + rotated * radius * radiusStrength;
    pushVertex(start + gl_LocalInvocationID.x, vec4(point, 1), rotated, 0, neuronId, sectionId, false);

    return point;
}

uint toParentIndex2(uint index, uint childIndex) {
    if (childIndex == 0) {
        if (index < verticesPerCircle / 2) return index;
        else return verticesPerCircle * 3 + index - verticesPerCircle / 2;
    } else {
        if (index < verticesPerCircle / 2) return verticesPerCircle * 3 + (verticesPerCircle / 2 - index - 1);
        else return index;
    }
}

void joint2(Joint joint) {
    // We are going to generate the following vertices:
    // - Parent circle: 16 vertices.
    // - Children circles: 16 vertices each -> 32 vertices.
    // - Split: 8 vertices. (16 / 2)
    // Total: 56 vertices. (POINTS_PER_CIRCLE * 3 + HALF_CIRCLE (ceil))

    // We are gonna generate the following triangles:
    // - Children: 32 triangles each -> 64 faces.
    // - 2 extra faces to fill the gaps.
    // Total: 68 faces. (POINTS_PER_CIRCLE * 4 + 2)

    uint slipVerticesAmount = verticesPerCircle / 2 + ((verticesPerCircle & 1) == 0 ? 0 : 1);
    SetMeshOutputsEXT(verticesPerCircle * 3 + slipVerticesAmount, verticesPerCircle * 4 + 2);
    // Generate the parent's circle first.

    uint rotationIndex = uint(ceil((joint.rotationIndex + rotationIndexOffset) * verticesPerCircle / 16.0f));
    uint childrenRotationIndex = uint(ceil((joint.rotationIndex + rotationIndexOffset + childrenRotationIndexOffset) * verticesPerCircle / 16.0f));

    Section parent = sections[joint.parent];
    Section grandParent = sections[parent.parent];

    float parentRadius = mix(grandParent.endAndRadius.w, parent.endAndRadius.w, 1.0f - endClip);

    vec3 startDirectionUnorm = parent.endAndRadius.xyz - grandParent.endAndRadius.xyz;
    vec3 startDirection = normalize(startDirectionUnorm);
    vec3 startCenter = parent.endAndRadius.xyz - startDirectionUnorm * endClip;

    if (gl_LocalInvocationID.x < verticesPerCircle) {
        parentCircle[gl_LocalInvocationID.x] =
        generateCircle(0, rotationIndex, startCenter, startDirection, startDirection, parentRadius, parent.neuronId, parent.sectionId);
    }

    uint childIndex = gl_LocalInvocationID.x / verticesPerCircle;
    uint localIndex = gl_LocalInvocationID.x % verticesPerCircle;
    Section section = parent;

    if (gl_LocalInvocationID.x < verticesPerCircle * 2) {
        // Generate the circles of all children.
        // (Yes, this will generate both circles).
        section = sections[joint.connection[childIndex]];
        vec3 endDirectionUnorm = section.endAndRadius.xyz - parent.endAndRadius.xyz;
        vec3 endDirection = normalize(endDirectionUnorm);
        vec3 endCenter = parent.endAndRadius.xyz + endDirectionUnorm * startClip;
        float endRadius = mix(parent.endAndRadius.w, section.endAndRadius.w, startClip);
        generateCircle(verticesPerCircle, childrenRotationIndex, endCenter, endDirection, startDirection, endRadius, section.neuronId, section.sectionId);
    }

    // Wait, we need the information of the first circle!
    barrier();

    // Generate the split.
    // We need the information of the following vertices:
    // - 0
    // - POINTS_PER_CIRCLE - 1
    // - POINTS_PER_CIRCLE / 2
    // - POINTS_PER_CIRCLE / 2 - 1
    // The split will contain half the amount of vertices inside a circle.
    // We start from half the circle and end on the start.
    if (gl_LocalInvocationID.x < slipVerticesAmount) {
        vec3 start = (parentCircle[verticesPerCircle / 2] + parentCircle[verticesPerCircle / 2 - 1]) / 2;
        vec3 end = (parentCircle[0] + parentCircle[verticesPerCircle - 1]) / 2;
        vec3 center = (start + end) / 2;

        // We calculate the percentage (0.0 - 1.0)
        float percentage = float(gl_LocalInvocationID.x) / float(slipVerticesAmount - 1);
        vec3 position = mix(start, end, percentage);

        vec3 strength = startDirectionUnorm * endClip * splitArcStrength;
        vec3 up = startDirectionUnorm * endClip * splitHeight;

        // Now we move the position to the center.
        position += (-4 * percentage * percentage + 4 * percentage) * strength + up;

        // We calculate the normal.
        vec3 normal = normalize(position - center);

        // Finally, we can push the vertex
        uint index = verticesPerCircle * 3 + gl_LocalInvocationID.x;

        pushVertex(index, vec4(position, 1), normal, 0, parent.neuronId, parent.sectionId, false);
    }

    if (gl_LocalInvocationID.x < verticesPerCircle * 2) {
        // Generate the triangles.
        // The tricky part here is to fetch the corresponding vertex from the parent circle.
        // Each local thread will generate one two triangles.
        uint start = verticesPerCircle + childIndex * verticesPerCircle;
        uint child1 = localIndex + start;
        uint child2 = ((localIndex + 1) % verticesPerCircle) + start;

        uint parent1 = toParentIndex2(localIndex, childIndex);
        uint parent2 = toParentIndex2((localIndex + 1) % verticesPerCircle, childIndex);

        gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationID.x] = uvec3(child1, child2, parent1);
        gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationID.x + verticesPerCircle * 2] = uvec3(parent1, parent2, child2);

        // Now we have to fill the gaps at the edge.
        if (gl_LocalInvocationID.x == 0) {
            uint gapStart = verticesPerCircle * 3;
            uint start = verticesPerCircle * 4;

            gl_PrimitiveTriangleIndicesEXT[start] = uvec3(verticesPerCircle / 2, verticesPerCircle / 2 - 1, gapStart);
            gl_PrimitiveTriangleIndicesEXT[start + 1] = uvec3(0, verticesPerCircle - 1, gapStart + verticesPerCircle / 2 - 1);
        }
    }
}

void main() {
    SetMeshOutputsEXT(0, 0);
    Joint joint = joints[td.joint];
    if (joint.amount == 1) {
        joint1(joint);
    } else if (joint.amount == 2) {
        joint2(joint);
    }
}