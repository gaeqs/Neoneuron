#version 460
#extension GL_EXT_mesh_shader: enable

const uint PRIMITIVES = 1;
const uint VERTICES = 3;
const uint GROUP_SIZE = 32;

const uint OUTPUT_PRIMITIVES = PRIMITIVES * GROUP_SIZE;
const uint OUTPUT_VERTICES = VERTICES * GROUP_SIZE;

layout (local_size_x = GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
layout (triangles, max_vertices = OUTPUT_VERTICES, max_primitives = OUTPUT_PRIMITIVES) out;

struct Vertex {
    vec4 position;
    vec2 uv;
};

layout(std430, set = 0, binding = 0) buffer Data {
    Vertex vertices[];
};

layout(set = 0, binding = 1) uniform Properties {
    mat4 model;
    int verticesAmount;
};

layout(location = 1) out vec2 outTexCoords[];

void pushVertex(uint i, Vertex vertex) {
    gl_MeshVerticesEXT[i].gl_Position = viewProjection * model * vertex.position;
    outTexCoords[i] = vertex.uv;
}

void calculateMeshOutput () {
    uint start = gl_WorkGroupID.x * GROUP_SIZE * VERTICES;
    uint end = min(start + VERTICES * GROUP_SIZE, verticesAmount);

    uint globalVerticesToProcess = end - start;
    uint globalPrimitivesToProcess = globalVerticesToProcess / 3;

    uint outputVertices = globalPrimitivesToProcess * 3;
    uint outputPrimitives = globalPrimitivesToProcess;
    SetMeshOutputsEXT(outputVertices, outputPrimitives);
}

void main() {
    if (gl_LocalInvocationID.x == 0) calculateMeshOutput();

    uint invocationId = gl_WorkGroupID.x * GROUP_SIZE + gl_LocalInvocationID.x;

    uint start = invocationId * VERTICES;
    uint end = min(start + VERTICES, verticesAmount);

    if (start >= end) return;

    uint v = gl_LocalInvocationID.x * OUTPUT_VERTICES_PER_THREAD;
    uint p = gl_LocalInvocationID.x * OUTPUT_PRIMITIVES_PER_THREAD;

    pushVertex(v, vertices[start]);
    pushVertex(v + 1, vertices[start + 1]);
    pushVertex(v + 2, vertices[start + 2]);
    gl_PrimitiveTriangleIndicesEXT[p] = uvec3(v, v + 1, v + 2);
}
    